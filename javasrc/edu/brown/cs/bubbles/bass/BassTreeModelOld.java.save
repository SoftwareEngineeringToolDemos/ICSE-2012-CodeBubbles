/********************************************************************************/
/*										*/
/*		BassTreeModelOld.java						*/
/*										*/
/*	Bubble Augmented Search Strategies tree model for a search		*/
/*										*/
/********************************************************************************/
/*	Copyright 2009 Brown University -- Steven P. Reiss		      */
/*********************************************************************************
 *  Copyright 2009, Brown University, Providence, RI.				 *
 *										 *
 *			  All Rights Reserved					 *
 *										 *
 *  Permission to use, copy, modify, and distribute this software and its	 *
 *  documentation for any purpose other than its incorporation into a		 *
 *  commercial product is hereby granted without fee, provided that the 	 *
 *  above copyright notice appear in all copies and that both that		 *
 *  copyright notice and this permission notice appear in supporting		 *
 *  documentation, and that the name of Brown University not be used in 	 *
 *  advertising or publicity pertaining to distribution of the software 	 *
 *  without specific, written prior permission. 				 *
 *										 *
 *  BROWN UNIVERSITY DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS		 *
 *  SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND		 *
 *  FITNESS FOR ANY PARTICULAR PURPOSE.  IN NO EVENT SHALL BROWN UNIVERSITY	 *
 *  BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY 	 *
 *  DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,		 *
 *  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS		 *
 *  ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 	 *
 *  OF THIS SOFTWARE.								 *
 *										 *
 ********************************************************************************/

/* RCS: $Header$ */

/*********************************************************************************
 *
 * $Log$
 *
 ********************************************************************************/


package edu.brown.cs.bubbles.bass;

import edu.brown.cs.bubbles.buda.BudaXmlWriter;


import javax.swing.tree.*;

import java.util.*;


class BassTreeModelOld extends DefaultTreeModel implements BassTreeModel, BassConstants
{



/********************************************************************************/
/*										*/
/*	Private Storage 							*/
/*										*/
/********************************************************************************/

private Collection<BassName>  start_set;
private Branch		root_node;
private String		initial_project;
private String		initial_prefix;
private int		leaf_count;
private boolean 	case_sensitive;

private static final long serialVersionUID = 1;



/********************************************************************************/
/*										*/
/*	Constructors								*/
/*										*/
/********************************************************************************/

BassTreeModelOld(BassRepository br,String proj,String clspfx)
{
   super(new Branch("ALL",null));

   initial_project = proj;
   initial_prefix = clspfx;

   root_node = (Branch) getRoot();
   start_set = new ArrayList<BassName>();
   leaf_count = 0;
   case_sensitive = false;

   for (BassName bn : br.getAllNames()) {
      if (proj != null && bn.getProject() != null && !proj.equals(bn.getProject())) continue;
      if (clspfx != null) {
	 if (!bn.getName().startsWith(clspfx)) continue;
       }
      start_set.add(bn);
    }

   setupInitial();
}




/********************************************************************************/
/*										*/
/*	Access methods								*/
/*										*/
/********************************************************************************/

@Override public int getLeafCount()			{ return leaf_count; }

@Override public int[] getIndicesOfFirstMethod()	{ return root_node.getIndicesOfFirstMethod(); }




/********************************************************************************/
/*										*/
/*	Top level methods							*/
/*										*/
/********************************************************************************/

@Override public BassName getSingleton()
{
   for (BassTreeImpl p = root_node; p.getChildCount() <= 1; p = p.getBassChild(0)) {
      if (p.isLeaf()) return p.getBassName();
      if (p.getChildCount() == 0) break;
    }

   return null;
}



@Override public void reset(String txt)
{
   BassNamePattern pat = new BassNamePattern(txt,case_sensitive);
   root_node.checkPattern(this,pat);		     // first eliminate any old nodes

   Set<BassName> active = new HashSet<BassName>();
   addNames(root_node,active);

   for (BassName nm : start_set) {
      if (active.contains(nm)) continue;
      if (pat.match(nm) < 0) continue;
      addNode(nm);
    }

   doneUpdate();
}


@Override public void rebuild(BassRepository br)
{
   synchronized(start_set){
      Set<BassName> dels = new HashSet<BassName>(start_set);
      Set<BassName> resultset = new HashSet<BassName>();
      for(BassName ba : br.getAllNames()) {
	 resultset.add(ba);
	 if(dels.remove(ba)) continue;
	 addNode(ba);
      }
      for(BassName ba : dels) {
	 removeNode(ba);
      }
      start_set = resultset;
   }
   doneUpdate();
}


@Override public void prune(String txt)
{
   BassNamePattern pat = new BassNamePattern(txt,case_sensitive);
   root_node.checkPattern(this,pat);
   doneUpdate();
}


private void addNames(BassTreeImpl tn,Set<BassName> active)
{
   if (tn.isLeaf()) active.add(tn.getBassName());
   else {
      for (Enumeration<?> e = tn.children(); e.hasMoreElements(); ) {
	 BassTreeImpl sn = (BassTreeImpl) e.nextElement();
	 addNames(sn,active);
       }
    }
}




/********************************************************************************/
/*										*/
/*	Setup methods								*/
/*										*/
/********************************************************************************/

private void setupInitial()
{
   List<BassName> items = new ArrayList<BassName>(start_set);
   Collections.sort(items,new TreeSorter());

   TreeLeaf last = null;
   for (BassName nm : items) {
      last = insertNode(nm,last);
    }

   root_node.collapseSingletons();

   doneUpdate();
}



private TreeLeaf insertNode(BassName nm,TreeLeaf last)
{
   String [] comps = nm.getNameComponents();
   int ncomp = comps.length;

   int idx = ncomp-2;			// ignore actual name

   Branch p = null;

   if (last == null) idx = -1;
   else {
      p = last.getBassParent();
      for ( ; ; ) {
	 if (p.getLocalName().equals(comps[idx])) break;
	 --idx;
	 if (idx < 0) break;
	 p = p.getBassParent();
	 if (p == null) break;
       }
    }
   if (idx < 0 || p == null) {
      p = root_node;
      idx = -1;
    }

   for (int i = idx+1; i < ncomp-1; ++i) {
      int n = p.getChildCount();
      Branch cn = null;
      if (n > 0) {
	 BassTreeImpl bti = p.getBassChild(n-1);
	 if (!bti.isLeaf() && bti.getLocalName().equals(comps[i])) {
	    cn = (Branch) bti;
	  }
       }
      if (cn == null) {
	 cn = new Branch(comps[i],p);
	 p.addChild(cn);
       }
      p = cn;
    }

   TreeLeaf tl = new TreeLeaf(nm,p);
   p.addChild(tl);
   ++leaf_count;

   return tl;
}



private void addNode(BassName nm)
{
   String [] comps = nm.getNameComponents();

   Branch p = root_node;
   for (int i = 0; i < comps.length-1; ++i) {
      int pri = (i == comps.length-1 ? nm.getSortPriority() : BASS_DEFAULT_INTERIOR_PRIORITY);
      p = p.findNode(this,comps[i],pri);
    }

   p.insertChild(this,nm);
   ++leaf_count;
}

private void removeNode(BassName nm)
{
   String [] comps = nm.getNameComponents();
   Branch p = root_node;
   for (int i = 0; i < comps.length-1; ++i) {
      int pri = (i == comps.length-1 ? nm.getSortPriority() : BASS_DEFAULT_INTERIOR_PRIORITY);
      p = p.findNode(this,comps[i],pri);
    }

   p.removeNode(this, nm);
   --leaf_count;
}


/********************************************************************************/
/*										*/
/*	Update methods								*/
/*										*/
/********************************************************************************/

@Override public void nodesWereInserted(TreeNode tn,int [] idx)
{
   // super.nodesWereInserted(tn,idx);
}



@Override public void nodesWereRemoved(TreeNode tn,int [] idx,Object [] chld)
{
   // super.nodesWereRemoved(tn,idx,chld);

   for (Object o : chld) {
      TreeNode dn = (TreeNode) o;
      if (dn.isLeaf()) --leaf_count;
    }
}



private void doneUpdate()
{
   reload(root_node);
}




/********************************************************************************/
/*										*/
/*	Expansion methods							*/
/*										*/
/********************************************************************************/

@Override public TreePath getTreePath(String nm)
{
   StringTokenizer tok = new StringTokenizer(nm,"@");
   Object [] elts = new Object[tok.countTokens()+1];
   TreeNode tn = root_node;
   int ect = 0;

   elts[ect++] = tn;
   while (tn != null && tok.hasMoreTokens()) {
      String snm = tok.nextToken();
      int ct = tn.getChildCount();
      TreeNode ctn = null;
      for (int i = 0; i < ct; ++i) {
	 BassTreeNode btn = (BassTreeNode) tn.getChildAt(i);
	 if (btn.getLocalName().equals(snm)) {
	    ctn = (TreeNode) btn;
	    break;
	  }
       }
      elts[ect++] = ctn;
      tn = ctn;
    }
   if (tn == null) return null;

   return new TreePath(elts);
}




/********************************************************************************/
/*										*/
/*	Output methods								*/
/*										*/
/********************************************************************************/

@Override public void outputXml(BudaXmlWriter xw)
{
   if (initial_project != null) xw.field("PROJECT",initial_project);
   if (initial_prefix != null) xw.field("PREFIX",initial_prefix);
   // TODO: output bubble type
}



/********************************************************************************/
/*										*/
/*	Sort order								*/
/*										*/
/********************************************************************************/

private static class TreeSorter implements Comparator<BassName> {

   @Override public int compare(BassName b1,BassName b2) {
      int d = b1.getSortPriority() - b2.getSortPriority();
      if (d != 0) return d;

      return b1.getFullName().compareTo(b2.getFullName());
    }

}	// end of inner class TreeSorter




/********************************************************************************/
/*										*/
/*	Tree node representation						*/
/*										*/
/********************************************************************************/

private static abstract class BassTreeImpl implements BassTreeNode, TreeNode {

   protected Branch parent_node;

   protected BassTreeImpl(Branch par) {
      parent_node = par;
    }

   @Override public TreeNode getParent()		{ return parent_node; }
   Branch getBassParent()				{ return parent_node; }

   @Override public BassName getBassName()		{ return null; }
   BassTreeImpl getBassChild(int idx)			{ return (BassTreeImpl) getChildAt(idx); }

   @Override abstract public String getLocalName();
   abstract boolean checkPattern(BassTreeModelOld mdl,BassNamePattern pat);

   int countLeafs()					{ return 0; }

   void collapseSingletons()				{ }

   @Override public String toString()			{ return getLocalName(); }

   abstract int getSortPriority();

}	// end of inner class BassTreeNode




private static class TreeLeaf extends BassTreeImpl {

   private BassName for_name;

   TreeLeaf(BassName nm,Branch par) {
      super(par);
      for_name = nm;
    }

   @Override public boolean getAllowsChildren() 	{ return false; }
   @Override public Enumeration<TreeNode> children()	{ return null; }
   @Override public TreeNode getChildAt(int idx)	{ return null; }
   @Override public int getChildCount() 		{ return 0; }
   @Override public int getIndex(TreeNode tn)		{ return -1; }
   @Override public boolean isLeaf()			{ return true; }

   int countLeafs()					{ return 1; }

   @Override public BassName getBassName()		{ return for_name; }
   @Override public String getLocalName()		{ return for_name.getDisplayName(); }

   int getSortPriority()				{ return for_name.getSortPriority(); }

   boolean checkPattern(BassTreeModelOld mdl,BassNamePattern pat) {
      return pat.match(for_name) >= 0;
    }

}	// end of inner class TreeLeaf



private static class Branch extends BassTreeImpl {

   private String local_name;
   private String display_name;
   private Vector<TreeNode> child_nodes;

   Branch(String name,Branch par) {
      super(par);
      local_name = name;
      display_name = name;
      child_nodes = new Vector<TreeNode>();
      int idx = name.indexOf("#");
      if (idx > 0) {
	 display_name = name.substring(idx+1);
       }
    }

   @Override public boolean getAllowsChildren() 	{ return true; }
   @Override public Enumeration<TreeNode> children()	{ return child_nodes.elements(); }
   @Override public TreeNode getChildAt(int idx) {
      if (idx > child_nodes.size()) return null;
      return child_nodes.get(idx);
    }
   @Override public int getChildCount() 		{ return child_nodes.size(); }
   @Override public int getIndex(TreeNode tn)		{ return child_nodes.indexOf(tn); }
   @Override public boolean isLeaf()			{ return false; }

   void addChild(TreeNode n)				{ child_nodes.add(n); }

   int countLeafs() {
      int ct = 0;
      for (TreeNode tn : child_nodes) ct += ((BassTreeImpl) tn).countLeafs();
      return ct;
    }

   int getSortPriority()				{ return BASS_DEFAULT_INTERIOR_PRIORITY; }

   void insertChild(BassTreeModelOld mdl,BassName nm) {
      String txt = nm.getNameWithParameters();
      int idx = 0;
      for (TreeNode tn : child_nodes) {
	 BassTreeImpl bt = (BassTreeImpl) tn;
	 if (txt.compareTo(bt.getLocalName()) <= 0) break;
	 ++idx;
       }
      TreeLeaf tl = new TreeLeaf(nm,this);
      child_nodes.insertElementAt(tl,idx);
      int [] idxs = new int[1];
      idxs[0] = idx;
      mdl.nodesWereInserted(this,idxs);
    }

   int[] getIndicesOfFirstMethod() {
      List<Integer> list = new ArrayList<Integer>();

      getIndicesOfFirstMethod(list);

      Integer[] aryIdx = new Integer[list.size()];
      list.toArray(aryIdx);

      int[] aryIndices = new int[list.size()];

      for(int i=0;i<aryIdx.length;i++)
	 aryIndices[i] = aryIdx[i].intValue();

      return aryIndices;
    }

   boolean getIndicesOfFirstMethod(List<Integer> list) {
      int index = 0;
      for (TreeNode tn : child_nodes) {
	 if (tn.isLeaf()) {
	    TreeLeaf leaf = (TreeLeaf) tn;
	    BassName bn = leaf.getBassName();
	    if (bn.getNameType() == BassNameType.METHOD || bn.getNameType() == BassNameType.CONSTRUCTOR) {
	       list.add(new Integer(index));
	       return true;
	     }
	  }
	 index++;
       }

      index = 0;
      for (TreeNode tn : child_nodes) {
	 if (!tn.isLeaf()) {
	    Branch branch = (Branch) tn;
	    if (branch.getIndicesOfFirstMethod(list)) {
	       list.add(new Integer(index + 1));
	       return true;
	     }
	  }
	 index++;
       }

      list.add(new Integer(index));

      return false;
    }

   @Override public String getLocalName()		{ return local_name; }
   @Override public String toString()			{ return display_name; }
   Branch getBassParent()				{ return parent_node; }

   Branch findNode(BassTreeModelOld mdl,String txt,int priority) {
      int idx = 0;
      for (TreeNode tn : child_nodes) {
	 BassTreeImpl bt = (BassTreeImpl) tn;
	 int d = priority - bt.getSortPriority();
	 if (d < 0) break;
	 if (d == 0) {
	    int comp = txt.compareTo(bt.getLocalName());
	    if (comp == 0) return (Branch) bt;
	    if (comp < 0) break;
	  }
	 ++idx;
       }
      Branch b = new Branch(txt,this);
      child_nodes.insertElementAt(b,idx);
      int [] indx = new int[1];
      indx[0] = idx;
      mdl.nodesWereInserted(this,indx);
      return b;
    }

   boolean checkPattern(BassTreeModelOld mdl,BassNamePattern pat) {
      List<Integer> rem = null;
      int idx = 0;
      for (TreeNode tn : child_nodes) {
	 BassTreeImpl bt = (BassTreeImpl) tn;
	 if (!bt.checkPattern(mdl,pat)) {
	    if (rem == null) rem = new ArrayList<Integer>();
	    rem.add(idx);
	  }
	 ++idx;
       }
      if (rem == null) return true;		// nothing changed;

      int [] chng = new int[rem.size()];
      Object [] chld = new Object[rem.size()];
      int ct = 0;
      for (Integer iv : rem) {
	 chng[ct++] = iv;
       }
      idx = 0;
      ct = 0;
      for (Iterator<TreeNode> it = child_nodes.iterator(); it.hasNext(); ) {
	 TreeNode tn = it.next();
	 if (ct < chng.length && idx == chng[ct]) {
	    it.remove();
	    chld[ct] = tn;
	    ++ct;
	  }
	 ++idx;
       }

      mdl.nodesWereRemoved(this,chng,chld);

      if (child_nodes.size() == 0 && parent_node != null) return false;

      return true;
    }

   boolean removeNode(BassTreeModelOld mdl, BassName bn)
   {
      List<Integer> rem = null;
      int idx = 0;
      for (TreeNode tn : child_nodes) {
	 BassTreeImpl bt = (BassTreeImpl) tn;
	 if (bt.getLocalName().equals(bn.getDisplayName())) {
	    if (rem == null) rem = new ArrayList<Integer>();
	    rem.add(idx);
	  }
	 ++idx;
       }
      if (rem == null) return false;		// nothing changed;

      int [] chng = new int[rem.size()];
      Object [] chld = new Object[rem.size()];
      int ct = 0;
      for (Integer iv : rem) {
	 chng[ct++] = iv;
       }
      idx = 0;
      ct = 0;
      for (Iterator<TreeNode> it = child_nodes.iterator(); it.hasNext(); ) {
	 TreeNode tn = it.next();
	 if (ct < chng.length && idx == chng[ct]) {
	    it.remove();
	    chld[ct] = tn;
	    ++ct;
	  }
	 ++idx;
       }

      mdl.nodesWereRemoved(this,chng,chld);

      return true;
   }

   void collapseSingletons() {
      if (parent_node != null) {
	 Branch cn = this;
	 StringBuffer buf = null;
	 while (cn.child_nodes.size() == 1) {
	    TreeNode tn = cn.getChildAt(0);
	    if (tn.isLeaf()) break;
	    if (buf == null) {
	       buf = new StringBuffer();
	       buf.append(cn.getLocalName());
	     }
	    else {
	       buf.append(".");
	       buf.append(cn.getLocalName());
	     }
	    cn = (Branch) tn;
	  }
	 if (cn != this) {
	    int idx = parent_node.getIndex(this);
	    cn.local_name = buf.toString() + "." + cn.local_name;
	    cn.parent_node = parent_node;
	    parent_node.child_nodes.set(idx,cn);
	    cn.collapseSingletons();
	    return;
	  }
       }
      for (TreeNode tn : child_nodes) {
	 BassTreeImpl ti = (BassTreeImpl) tn;
	 ti.collapseSingletons();
       }
    }

}	// end of inner class Branch



}	// end of class BassTreeModelOld



/* end of BassTreeModelOld.java */
